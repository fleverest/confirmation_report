---
title: "Risk-limiting Bayesian Ballot-polling Audits for Plurality"
author: Floyd Everest
organization: Econometrics and Business Statistics
bibliography: references.bib
format:
  revealjs:
    header-includes: |
      <link rel="stylesheet" href="https://unpkg.com/98.css" />
      <link href="style.css" rel="stylesheet">
---

## Warning: may contain

* Fiction

. . .

* Nostalgia

. . .

* References you're too young for


# Risk-limiting Bayesian Ballot-polling Audits for Plurality

# Risk-limiting Bayesian Ballot-polling [Audits]{style="background-color:yellow;"} for Plurality

# [Risk-limiting]{style="background-color:yellow;"} Bayesian Ballot-polling Audits for Plurality

# Risk-limiting Bayesian [Ballot-polling]{style="background-color:yellow;"} Audits for Plurality

# Risk-limiting Bayesian Ballot-polling Audits for [Plurality]{style="background-color:yellow;"}

# Risk-limiting [Bayesian]{style="background-color:yellow;"} Ballot-polling Audits for Plurality

# Post-election Audits

## What?

* After "the count", a *reported outcome* is released
* With access to the *audit-trail*
* *Certify* as correct, or correct the outcome

## Why?

* Make sure reported outcome is true
  * Software bugs (e.g., scanners)
  * Human error (e.g., interference, tired eyes)

. . . 

```{=html}
<script>
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
async function fadeInClive(){
  await sleep(5000);
  document.getElementsByClassName('fig-clive').forEach(
    (el) => {el.classList.toggle("fade-in");}
  );
}
</script>
<div class="flex-container">
  <div class="window">
    <div class="title-bar">
      <div class="title-bar-text">
        Reported outcome available!
      </div>
      <div class="title-bar-controls">
        <button aria-label="Close"></button>
      </div>
    </div>
    <div class="window-body" style="font-size: 20pt;">
      <p>Accept at face value?</p>
      <div class="field-row">
        <button onclick="Reveal.next();fadeInClive();">Yes</button>
        <button onclick="for(let i=0; i<2; i++){Reveal.next();};">No</button>
      </div>
    </div>
  </div>
</div>
```

## This is why.

::: {#fig-98-popup-error}
```{=html}
<div class="flex-container">
  <div class="window" style="margin: 32px; max-width: 50%;">
    <div class="title-bar">
      <div class="title-bar-text">
        Error
      </div>
      <div class="title-bar-controls">
        <button aria-label="Close"></button>
      </div>
    </div>
    <div class="window-body" style="font-size: 20pt;">
      <div class="window-error">
        <div class="error-icon"><img src="https://win98icons.alexmeub.com/icons/png/msg_warning-0.png"/>
        </div>
        <div class="error-message">
          Oops! You seated Clive Palmer!
        </div>
      </div>
      <div class="field-row">
        <button onclick="Reveal.prev();">Go Back</button>
      </div>
    </div>
  </div>
</div>
```
:::

![](media/clive_palmer_dinosaur.avif){.fig-clive width=400}


## How?

If the audit-trail is reliable, we can just recount using these records.
But:

* Reliable audit-trails are often paper records
  * original paper ballots
  * voter-verifiable paper records
* Manually checking paper records is expensive


## Statistical audits

If we can sample ballots *at random*, we can use statistics!

* Goals:
  * Detect incorrect reported outcome with high *probability*
  * Use as few samples as possible

## Hypothesis testing

$$
H_0: \text{"Reported outcome is false."}
$$ versus
$$
H_1: \text{"Reported outcome is true."}
$$

* Take a relatively small sample
* *Decide* between $H_0$ and $H_1$

## Sequential hypothesis testing

* Sample one-by-one (or in relatively small batches)
* *Decide* between $H_0$, $H_1$, or continuing to sample


## Risk-limiting audits (RLAs)

Guaranteed to correct an incorrect outcome with a probability of at least 1-$\alpha$

* Legal definition!!
  * Not just detect, but also *correct* erroneous outcomes
* But, for now:
  * "Risk-limit" $\longleftrightarrow$ "Level" or "Significance"
  * "Risk-limiting audit" $\longleftrightarrow$ "Level-$\alpha$ test"


## Ballot-polling audits

A simple framework for statistical audits.

::: {#fig-windows-file-copy}
![](media/file_copy.mp4){height="250" loop="true" autoplay="true"}

Sampling without replacement (Source - Windows 95)
:::

Stops when we run out of ballots, or early if we reach a decision.

## Ballot-polling audits

A simple framework for statistical audits.

::: {#fig-windows-file-copy-with-replacement}
![](media/file_copy_with_replacement.mp4){height="250" loop="true" autoplay="true"}

Sampling with replacement (Source - Windows 95)
:::

Only stops when we make a decision!


## Plurality: The Simplest Electoral System

* Candidates $1,\dots,K$
* Voters choose one candidate to vote for
* Whoever gets the most votes wins

## The Hypothesis Test

* Two candidates: A and B
* Reported winner is A
* Proportions $\mathbf{p}=(p_A,p_B)'$

$$
H_0:\ \mathbf{p}\in\Theta_0 = \{\mathbf{p}:p_B\geq p_A\}
$$

$$
H_1:\ \mathbf{p}\in\Theta_1 = \{\mathbf{p}:p_A>p_B\}
$$

## Ballot-polling Stochastic Process

Sample counts over time:

```{r}
library(tidyverse)
set.seed(1)
n_lines <- 10
line_len <- 10
counts <- rbinom(n=line_len, size=1, prob=0.5) |>
  cumsum() |>
  cbind(time=1:line_len, count=_) |>
  as_tibble() |>
  replicate(10, expr=_, simplify=FALSE) |>
  mapply(FUN=\(x, i) {x$id <- i; x}, 1:n_lines) |>
  apply(2L, as.data.frame) |>
  do.call(what=rbind)
counts |>
  ggplot(aes(x=time, y=count, group=id, color=as.factor(id))) +
  geom_line(position=position_jitter(w=0.1, h=0)) +
  ylab("Count for candidate 1") +
  xlab("Number of ballots sampled") +
  theme(legend.position="none")
```

## Ballot-polling Stochastic Process

Illustrating sample proportions over time:

```{r}
library(tidyverse)
set.seed(1)
n_lines <- 10
line_len <- 10
counts <- rbinom(n=line_len, size=1, prob=0.5) |>
  cummean() |>
  cbind(time=1:line_len, count=_) |>
  as_tibble() |>
  replicate(10, expr=_, simplify=FALSE) |>
  mapply(FUN=\(x, i) {x$id <- i; x}, 1:n_lines) |>
  apply(2L, as.data.frame) |>
  do.call(what=rbind)
counts |>
  ggplot(aes(x=time, y=count, group=id, color=as.factor(id))) +
  geom_line(position=position_jitter(w=0.1, h=0)) +
  ylab("Proportion for candidate 1") +
  xlab("Number of ballots sampled") +
  theme(legend.position="none")
```

## Sample proportions

```{r}
require(Ternary)
TernaryPlot(atip="A", btip="B", ctip="C", axis.labels = FALSE, axis.tick = FALSE, grid.lines = 2)
points <- list(
  c(0.2, 0.3, 0.5)
)
TernaryPoints(head(points, -1), col = "black")
TernaryPoints(tail(points, 1), col = "blue")
```

## Sample proportions

```{r}
TernaryPlot(atip="A", btip="B", ctip="C", axis.labels = FALSE, axis.tick = FALSE, grid.lines = 2)
points <- list(
  c(0.2, 0.3, 0.5),
  c(0.3, 0.5, 0.2)
)
TernaryPoints(head(points, -1), col = "black")
TernaryPoints(tail(points, 1), col = "blue")
for (i in seq_along(head(points, -1))) {
  TernaryArrows(points[i], points[i+1], length = 0.05, col = "black")
}
```


## Sample proportions

```{r}
TernaryPlot(atip="A", btip="B", ctip="C", axis.labels = FALSE, axis.tick = FALSE, grid.lines = 2)
points <- list(
  c(0.2, 0.3, 0.5),
  c(0.3, 0.5, 0.2),
  c(0.45, 0.35, 0.2)
)
TernaryPoints(head(points, -1), col = "black")
TernaryPoints(tail(points, 1), col = "blue")
for (i in seq_along(head(points, -1))) {
  TernaryArrows(points[i], points[i+1], length = 0.05, col = "black")
}
```

## Sample proportions

```{r}
TernaryPlot(atip="A", btip="B", ctip="C", axis.labels = FALSE, axis.tick = FALSE, grid.lines = 2)
points <- list(
  c(0.2, 0.3, 0.5),
  c(0.3, 0.5, 0.2),
  c(0.45, 0.35, 0.2),
  c(0.31, 0.31, 0.38)
)
TernaryPoints(head(points, -1), col = "black")
TernaryPoints(tail(points, 1), col = "blue")
for (i in seq_along(head(points, -1))) {
  TernaryArrows(points[i], points[i+1], length = 0.05, col = "black")
}
```

## Sample proportions

```{r}
TernaryPlot(atip="A", btip="B", ctip="C", axis.labels = FALSE, axis.tick = FALSE, grid.lines = 2)
points <- list(
  c(0.2, 0.3, 0.5),
  c(0.3, 0.5, 0.2),
  c(0.45, 0.35, 0.2),
  c(0.31, 0.31, 0.38),
  c(0.3, 0.37, 0.33)
)
TernaryPoints(head(points, -1), col = "black")
TernaryPoints(tail(points, 1), col = "blue")
for (i in seq_along(head(points, -1))) {
  TernaryArrows(points[i], points[i+1], length = 0.05, col = "black")
}
```


## The Hypothesis Test

* Audit-trail proportions define true outcomes
* Sample proportions converge to this value

```{r}
TernaryPlot(atip=expression(p[A]), btip=expression(p[B]), ctip=expression(p[C]), axis.labels = FALSE, axis.tick = FALSE)
TernaryPolygon(list(c(1,0,0), c(1/2, 1/2, 0), c(1/3,1/3,1/3), c(1/2, 0, 1/2)), col = "#EEEEEE")
TernaryPolygon(list(c(1/2,1/2,0), c(1/3, 1/3, 1/3), c(1/2,0,1/2), c(0, 0, 1), c(0, 1, 0)), col = "#AAAAAA")
text(0, 0.5, expression(Theta[1]), cex=2)
text(0, 0.15, expression(Theta[0]), cex=2)
```


## Sequential Decision Rules $d$

Given:

* The "time" $n$
* A finite sequence of ballots $\mathbf{b}^n=(b_1,\dots,b_n)$

We choose $d(\mathbf{b}^n)$, one of:

* Continue sampling
* Certify reported outcome
* Stop without certifying

## Sample coherence

$d$ is sample-coherent if we certify only when sample-proportions support reported outcome.

```{r}
TernaryPlot(atip=expression(p[A]), btip=expression(p[B]), ctip=expression(p[C]), axis.labels = FALSE, axis.tick = FALSE)
TernaryPolygon(list(c(1,0,0), c(1/2, 1/2, 0), c(1/3,1/3,1/3), c(1/2, 0, 1/2)), col = "#EEEEEE")
TernaryPolygon(list(c(1/2,1/2,0), c(1/3, 1/3, 1/3), c(1/2,0,1/2), c(0, 0, 1), c(0, 1, 0)), col = "#AAAAAA")
text(0, 0.5, expression(Theta[1]), cex=2)
text(0, 0.15, expression(Theta[0]), cex=2)
```

## Worst-case risk

```{r}
TernaryPlot(atip=expression(p[A]), btip=expression(p[B]), ctip=expression(p[C]), axis.labels = FALSE, axis.tick = FALSE)
TernaryPolygon(list(c(1,0,0), c(1/2, 1/2, 0), c(1/3,1/3,1/3), c(1/2, 0, 1/2)), col = "#EEEEEE")
TernaryPolygon(list(c(1/2,1/2,0), c(1/3, 1/3, 1/3), c(1/2,0,1/2), c(0, 0, 1), c(0, 1, 0)), col = "#AAAAAA", )
TernaryLines(list(c(1/2,1/2,0), c(1/3,1/3,1/3), c(1/2,0,1/2)), col="red", lwd=4)
text(0, 0.5, expression(Theta[1]), cex=2)
text(0, 0.15, expression(Theta[0]), cex=2)
```


## Bayesian audits

* Define a prior on $\Theta$ (Dirichlet)
* Yield posterior using current sample $\mathbf{b}^n$
* Calculate posterior probability of $\Theta_1$
* Certify if this exceeds some pre-defined threshold $\kappa>0.5$

## Worst-case for Bayesian audits

Bayesian audits with "symmetric" Dirichlet prior are sample-coherent.

```{r}
TernaryPlot(atip=expression(p[A]), btip=expression(p[B]), ctip=expression(p[C]), axis.labels = FALSE, axis.tick = FALSE)
TernaryPolygon(list(c(1,0,0), c(1/2, 1/2, 0), c(1/3,1/3,1/3), c(1/2, 0, 1/2)), col = "#EEEEEE")
TernaryPolygon(list(c(1/2,1/2,0), c(1/3, 1/3, 1/3), c(1/2,0,1/2), c(0, 0, 1), c(0, 1, 0)), col = "#AAAAAA", )
TernaryLines(list(c(1/2,1/2,0), c(1/3,1/3,1/3), c(1/2,0,1/2)), col="red", lwd=4)
text(0, 0.5, expression(Theta[1]), cex=2)
text(0, 0.15, expression(Theta[0]), cex=2)
```

## Worst-case for Bayesian audits

Empirical analysis showed that the worst case risk is the two-way tie

```{r}
TernaryPlot(atip=expression(p[A]), btip=expression(p[B]), ctip=expression(p[C]), axis.labels = FALSE, axis.tick = FALSE)
TernaryPolygon(list(c(1,0,0), c(1/2, 1/2, 0), c(1/3,1/3,1/3), c(1/2, 0, 1/2)), col = "#EEEEEE")
TernaryPolygon(list(c(1/2,1/2,0), c(1/3, 1/3, 1/3), c(1/2,0,1/2), c(0, 0, 1), c(0, 1, 0)), col = "#AAAAAA", )
TernaryPoints(list(c(1/2,1/2,0), c(1/2,0,1/2)), col="red")
text(0, 0.5, expression(Theta[1]), cex=2)
text(0, 0.15, expression(Theta[0]), cex=2)
```

## Estimating Worst-case Risk

* Fix threshold and Dirichlet prior
* Calculate risk via Monte Carlo integration:
  * Simulate audits with $\mathbf{p}=(1/2, 1/2, 0, \dots)'$
  * Count number of certifications

## Tuning Audit Parameters

* Fix Dirichlet prior
* Search for some $\kappa\in [1/2, 1)$ such that risk$\leq\alpha$
  * Binary search
  * "Sharp Noisy Binary Search" @gretta2023sharpnoisybinarysearch


# Plans for the future

## Develop tools for sequential testing

* Common in industry
  * Sequential A/B testing
  * SPRT
* Few open-source projects
* Different packages have different structures
* Active area of research


## `test_smart`

* `test_smart` as a unified sequential testing library on which to base other tests


## Optimising Supermartingale Intersection Tests

* Sequential decision rules often use test supermartingales
  * A non-negative stochastic process
  * Under $H_0$, will not exceed $1/\alpha$ with probability $1-\alpha$
  * Ville's inequality


## Optimising Supermartingale Intersection Tests

* Convex combinations are still supermartingales
  * Intersection supermartingale
* Weights are allowed to change at each step
* @ek2023awaire use different weighted averages of test supermartingales
* Portfolio algorithms could optimise performance


## The End

```{=html}
<div class="flex-container">
  <div class="window">
    <div class="title-bar">
      <div class="title-bar-text">
        Shut Down Windows
      </div>
      <div class="title-bar-controls">
        <button aria-label="Close"></button>
      </div>
    </div>
    <div class="window-body" style="font-size: 20pt;">
      <div class="window-error">
        <div class="shutdown-icon"><img src="https://win98icons.alexmeub.com/icons/png/shut_down_normal-4.png"/>
        </div>
        <div class="shutdown-message">
          Are you sure you want to:
          <div class="field-row">
            <input id="radio1" type="radio" name="fieldset-example2" checked>
            <label for="radio1">Shut down the computer?</label>
          </div>
          <div class="field-row">
            <input id="radio2" type="radio" name="fieldset-example2">
            <label for="radio2">Restart the computer?</label>
          </div>
          <div class="field-row">
            <input id="radio3" type="radio" name="fieldset-example2">
            <label for="radio3">Restart the computer in MS-DOS mode?</label>
          </div>
          <div class="field-row">
            <input id="radio4" type="radio" name="fieldset-example2">
            <label for="radio4">Close all programs and log on as different user?</label>
          </div>
        </div>
      </div>
      <div class="field-row">
        <button onclick="Reveal.next();">Yes</button>
        <button onclick="Reveal.next();">No</button>
        <button onclick="Reveal.next();">Help</button>
      </div>
    </div>
  </div>
</div>
```

## {transition="fade-in" background-image="media/shut_down_safe.png"}